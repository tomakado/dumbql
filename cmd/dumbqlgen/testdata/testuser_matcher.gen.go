// Code generated by dumbqlgen (devel); DO NOT EDIT.
package testdata

import (
	"go.tomakado.io/dumbql/match"
)

// TestUserRouter is a generated Router implementation for TestUser.
// It implements the match.Router interface.
type TestUserRouter struct{}

// NewTestUserMatcher creates a new StructMatcher with a generated router for TestUser.
func NewTestUserMatcher() *match.StructMatcher {
	return match.NewStructMatcher(&TestUserRouter{})
}

// Route resolves a field path in the target TestUser and returns the value.
// It supports nested field access using dot notation (e.g., "address.city").
func (r *TestUserRouter) Route(target any, field string) (any, error) {
	var (
		cursor = target
		err      error
	)

	for field := range match.Path(field) {
		if field == "" {
			return nil, match.ErrFieldNotFound
		}

		cursor, err = r.resolveField(target, field)
		if err != nil {
			return nil, err
		}
	}

	return cursor, nil
}

// resolveField handles resolving a direct field (no dots in the name)
func (r *TestUserRouter) resolveField(target any, field string) (any, error) {
	obj, err := r.normalizeTestUser(target)
	if err != nil {
		return nil, err
	}

	switch field {
	case "id":
		return obj.ID, nil
	case "name":
		return obj.Name, nil
	case "email":
		return obj.Email, nil
	case "CreatedAt":
		return obj.CreatedAt, nil
	case "address":
		return obj.Address, nil
	default:
		return nil, match.ErrFieldNotFound
	}
}

func (r *TestUserRouter) normalizeTestUser(target any) (*TestUser, error) {
	// Normalize the target to a pointer to TestUser
	if obj, ok := target.(*TestUser); ok {
		if obj == nil {
			return nil, match.ErrNotAStruct
		}
		return obj, nil
	}
	if obj, ok := target.(TestUser); ok {
		return &obj, nil
	}
	return nil, match.ErrNotAStruct
}
