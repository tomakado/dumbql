// Code generated by dumbqlgen (devel); DO NOT EDIT.
package testdata

import (
	"go.tomakado.io/dumbql/match"
)

// BenchUserRouter is a generated Router implementation for BenchUser.
// It implements the match.Router interface.
type BenchUserRouter struct{}

// NewBenchUserMatcher creates a new StructMatcher with a generated router for BenchUser.
func NewBenchUserMatcher() *match.StructMatcher {
	return match.NewStructMatcher(&BenchUserRouter{})
}

// Route resolves a field path in the target BenchUser and returns the value.
// It supports nested field access using dot notation (e.g., "address.city").
func (r *BenchUserRouter) Route(target any, field string) (any, error) {
	var (
		cursor = target
		err      error
	)

	for field := range match.Path(field) {
		if field == "" {
			return nil, match.ErrFieldNotFound
		}

		cursor, err = r.resolveField(target, field)
		if err != nil {
			return nil, err
		}
	}

	return cursor, nil
}

// resolveField handles resolving a direct field (no dots in the name)
func (r *BenchUserRouter) resolveField(target any, field string) (any, error) {
	obj, err := r.normalizeBenchUser(target)
	if err != nil {
		return nil, err
	}

	switch field {
	case "id":
		return obj.ID, nil
	case "name":
		return obj.Name, nil
	case "email":
		return obj.Email, nil
	case "age":
		return obj.Age, nil
	case "CreatedAt":
		return obj.CreatedAt, nil
	case "active":
		return obj.Active, nil
	default:
		return nil, match.ErrFieldNotFound
	}
}

func (r *BenchUserRouter) normalizeBenchUser(target any) (*BenchUser, error) {
	// Normalize the target to a pointer to BenchUser
	if obj, ok := target.(*BenchUser); ok {
		if obj == nil {
			return nil, match.ErrNotAStruct
		}
		return obj, nil
	}
	if obj, ok := target.(BenchUser); ok {
		return &obj, nil
	}
	return nil, match.ErrNotAStruct
}
