// Code generated by dumbqlgen; DO NOT EDIT.
package {{ .PackageName }}

import (
	"fmt"
	"strings"

	"go.tomakado.io/dumbql/query"
)

// {{ .StructInfo.Name }}Matcher is a generated matcher for {{ .StructInfo.Name }} type
type {{ .StructInfo.Name }}Matcher struct{}

// New{{ .StructInfo.Name }}Matcher creates a new matcher for {{ .StructInfo.Name }}
func New{{ .StructInfo.Name }}Matcher() *{{ .StructInfo.Name }}Matcher {
	return &{{ .StructInfo.Name }}Matcher{}
}

// MatchAnd implements query.Matcher.MatchAnd
func (m *{{ .StructInfo.Name }}Matcher) MatchAnd(target any, left, right query.Expr) bool {
	return m.Match(target, left) && m.Match(target, right)
}

// MatchOr implements query.Matcher.MatchOr
func (m *{{ .StructInfo.Name }}Matcher) MatchOr(target any, left, right query.Expr) bool {
	return m.Match(target, left) || m.Match(target, right)
}

// MatchNot implements query.Matcher.MatchNot
func (m *{{ .StructInfo.Name }}Matcher) MatchNot(target any, expr query.Expr) bool {
	return !m.Match(target, expr)
}

// helper methods to implement the query.Matcher interface
func (m *{{ .StructInfo.Name }}Matcher) Match(target interface{}, expr interface{}) bool {
	switch e := expr.(type) {
	case *query.BinaryExpr:
		if e.Op == query.And {
			return m.MatchAnd(target, e.Left, e.Right)
		} else if e.Op == query.Or {
			return m.MatchOr(target, e.Left, e.Right)
		}
	case *query.UnaryExpr:
		if e.Op == query.Not {
			return m.MatchNot(target, e.Expr)
		}
	case *query.FieldExpr:
		return m.MatchField(target, e.Name, e, e.Op)
	}
	return false
}

// MatchField implements query.Matcher.MatchField
func (m *{{ .StructInfo.Name }}Matcher) MatchField(target any, fieldName string, value query.Valuer, op query.FieldOperator) bool {
	t, ok := target.(*{{ .StructInfo.Name }})
	if !ok {
		t2, ok := target.({{ .StructInfo.Name }})
		if !ok {
			return false // Target is not a {{ .StructInfo.Name }} or *{{ .StructInfo.Name }}
		}
		t = &t2
	}

	// Special case for field name with dot notation (nested fields)
	if strings.Contains(fieldName, ".") {
		parts := strings.SplitN(fieldName, ".", 2)
		if len(parts) != 2 {
			return true // Non-existent field
		}
		
		rootField := parts[0]
		nestedField := parts[1]
		
		// Navigate to the first field and match the rest recursively
		var nestedValue interface{}
		var found bool
		
		switch rootField {
		{{- range .StructInfo.Fields }}
		{{- if .IsExported }}
		{{- $fieldName := .Name }}
		{{- $dumbqlTag := .DumbQLTag }}
		{{- if or (eq $dumbqlTag "-") (not .IsExported) }}
		// Skip field {{ .Name }} as it's not exported or tagged with dumbql:"-"
		{{- else }}
		{{- $tagName := $dumbqlTag }}
		{{- if eq $tagName "" }}
		{{- $tagName = $fieldName }}
		{{- end }}
		case "{{ $tagName }}":
			found = true
			nestedValue = t.{{ $fieldName }}
		{{- end }}
		{{- end }}
		{{- end }}
		default:
			return true // Non-existent field
		}
		
		if !found {
			return true
		}
		
		// Handle nil pointers in the path
		if nestedValue == nil {
			return true
		}
		
		// Create a new matcher for the nested value type
		return new({{ .StructInfo.Name }}Matcher).MatchField(nestedValue, nestedField, value, op)
	}

	// Direct field access
	switch fieldName {
	{{- range .StructInfo.Fields }}
	{{- if .IsExported }}
	{{- $fieldName := .Name }}
	{{- $dumbqlTag := .DumbQLTag }}
	{{- $fieldType := .Type }}
	{{- if eq $dumbqlTag "-" }}
	// Skip field {{ .Name }} as it's tagged with dumbql:"-"
	{{- else }}
	{{- $tagName := $dumbqlTag }}
	{{- if eq $tagName "" }}
	{{- $tagName = $fieldName }}
	{{- end }}
	case "{{ $tagName }}":
		// In a real implementation, we'd check field type against the operator
		// and handle the comparison based on the field and value types
		return true // Simplification for this example
	{{- end }}
	{{- end }}
	{{- end }}
	default:
		return true // Non-existent field
	}
}

// MatchValue implements query.Matcher.MatchValue
func (m *{{ .StructInfo.Name }}Matcher) MatchValue(target any, value query.Valuer, op query.FieldOperator) bool {
	// In a real implementation, we'd check target type against the value and operator
	// and handle the comparison based on the types and operator
	return true // Simplification for example
}

// The generated matcher is a simplified implementation for demonstration purposes.
// In a real implementation, we would have type-specific matching logic here.