// Code generated by dumbqlgen (devel); DO NOT EDIT.
package examples

import (
	"go.tomakado.io/dumbql/match"
)

// UserRouter is a generated Router implementation for User.
// It implements the match.Router interface.
type UserRouter struct{}

// NewUserMatcher creates a new StructMatcher with a generated router for User.
func NewUserMatcher() *match.StructMatcher {
	return match.NewStructMatcher(&UserRouter{})
}

// Route resolves a field path in the target User and returns the value.
// It supports nested field access using dot notation (e.g., "address.city").
func (r *UserRouter) Route(target any, field string) (any, error) {
	var (
		cursor = target
		err      error
	)

	for field := range match.Path(field) {
		if field == "" {
			return nil, match.ErrFieldNotFound
		}

		cursor, err = r.resolveField(target, field)
		if err != nil {
			return nil, err
		}
	}

	return cursor, nil
}

// resolveField handles resolving a direct field (no dots in the name)
func (r *UserRouter) resolveField(target any, field string) (any, error) {
	obj, err := r.normalizeUser(target)
	if err != nil {
		return nil, err
	}

	switch field {
	case "id":
		return obj.ID, nil
	case "name":
		return obj.Name, nil
	case "email":
		return obj.Email, nil
	case "CreatedAt":
		return obj.CreatedAt, nil
	case "address":
		return obj.Address, nil
	default:
		return nil, match.ErrFieldNotFound
	}
}

func (r *UserRouter) normalizeUser(target any) (*User, error) {
	// Normalize the target to a pointer to User
	if obj, ok := target.(*User); ok {
		if obj == nil {
			return nil, match.ErrNotAStruct
		}
		return obj, nil
	}
	if obj, ok := target.(User); ok {
		return &obj, nil
	}
	return nil, match.ErrNotAStruct
}
