// Code generated by dumbqlgen {{.Version}}; DO NOT EDIT.
package {{.Package}}

import (
	"go.tomakado.io/dumbql/match"
)

// {{.StructInfo.Name}}Router is a generated Router implementation for {{.StructInfo.Name}}.
// It implements the match.Router interface.
type {{.StructInfo.Name}}Router struct{}

// New{{.StructInfo.Name}}Matcher creates a new StructMatcher with a generated router for {{.StructInfo.Name}}.
func New{{.StructInfo.Name}}Matcher() *match.StructMatcher {
	return match.NewStructMatcher(&{{.StructInfo.Name}}Router{})
}

// Route resolves a field path in the target {{.StructInfo.Name}} and returns the value.
// It supports nested field access using dot notation (e.g., "address.city").
func (r *{{.StructInfo.Name}}Router) Route(target any, field string) (any, error) {
	var (
		cursor = target
		err      error
	)

	for field := range match.Path(field) {
		if field == "" {
			return nil, match.ErrFieldNotFound
		}

		cursor, err = r.resolveField(target, field)
		if err != nil {
			return nil, err
		}
	}

	return cursor, nil
}

// resolveField handles resolving a direct field (no dots in the name)
func (r *{{.StructInfo.Name}}Router) resolveField(target any, field string) (any, error) {
	obj, err := r.normalize{{.StructInfo.Name}}(target)
	if err != nil {
		return nil, err
	}

	switch field {
	{{- range .StructInfo.Fields}}
	{{- if not .Skip}}
	case "{{.TagName}}":
		return obj.{{.Name}}, nil
	{{- end}}
	{{- end}}
	default:
		return nil, match.ErrFieldNotFound
	}
}

func (r *{{.StructInfo.Name}}Router) normalize{{.StructInfo.Name}}(target any) (*{{.StructInfo.Name}}, error) {
	// Normalize the target to a pointer to {{.StructInfo.Name}}
	if obj, ok := target.(*{{.StructInfo.Name}}); ok {
		if obj == nil {
			return nil, match.ErrNotAStruct
		}
		return obj, nil
	}
	if obj, ok := target.({{.StructInfo.Name}}); ok {
		return &obj, nil
	}
	return nil, match.ErrNotAStruct
}
